/*
* Hashset API.
*
* Motivation:
* A hashset is efficient for storing and retrieving elements.
* The C hashset uses the same code for all types. 
* It avoids the "code bloat" generated by template classes in C++.
*
* Reference:
* Stanford CS107
*
* Authors:
* Jerry Cain, revised by Elizabeth Howe
*/

#ifndef _HASHSET_H_
#define _HASHSET_H_

#include "vector.h"
#include "hashset_internal.h"

/*
 * A client-supplied function pointer mapping the element at the specified
 * elem_addr to some number (the hash code) between 0 and num_buckets - 1.
 * The hash function must be deterministic. The same number must be returned
 * each time the same element is hashed (where same is defined in the 
 * hashset_cmp_fun sense). 
 * The hash routine distributes the spectrum of client elements as uniformly 
 * as possible over the [0, num_buckets) range.
 */
typedef int (*hashset_hash_fun)(const void *elem_addr, int num_buckets);

/*
 * A client-supplied function to compare two elements, each identified
 * by address.
 * A negative return value means that the item addressed by elem_addr1
 * is less than the item addressed by elem_addr2.
 * A zero return value means that the two items addressed by elem_addr1
 * and elem_addr2 are equal.
 * A positive return value means that the item addressed by elem_addr2
 * is less than the item addressed by elem_addr1.
 */
typedef int (*hashset_cmp_fun)(const void *elem_addr1, const void *elem_addr2);

/* 
 * A client-supplied function pointer used to map over the elements in 
 * hashset.  
 * This function is called with a pointer to the element and a client data 
 * pointer.
 */
typedef void (*hashset_map_fun)(void *elem_addr, void *aux_data);

/* 
 * A client-supplied function pointer used as the clean-up function for each 
 * element. 
 */
typedef void (*hashset_free_fun)(void *elem_addr);

/*
 * Construct an empty hashset in the caller's stack.
 * 
 * elem_size specifies the number of bytes that an element of the
 * table should take up. 
 *
 * num_buckets specifies the number of buckets that the elements
 * will be partitioned into. Once a hashset is created, this number does
 * not change. The num_buckets parameter must be in sync with the behavior of
 * the hash_fun, which must return a hash code between 0 and num_buckets - 1.   
 * The hash_fun specifies the function that is called to retrieve the
 * hash code for a given element.
 *
 * cmp_fun is used for testing equality between elements.
 *
 * free_fun is the function that will be called on an element that is
 * about to be overwritten (by a new entry in hashset_enter) or on each element 
 * in the table when the entire table is being freed (using hashset_dispose). 
 * If free_fun is NULL, the elements don't require any special handling.
 */
void hashset_new(hashset *h, int elem_size, int num_buckets, 
		         hashset_hash_fun hash_fun, hashset_cmp_fun cmp_fun, 
                 hashset_free_fun free_fun);

/* Free up memory consumed by hashset */
void hashset_dispose(hashset *h);

/* Return the number of elements residing in the hashset. */
int hashset_count(const hashset *h);

/*
 * Insert the element at the given elem_addr into the specified hashset.  
 * If the specified element matches an element previously inserted 
 * (as far as the hash and compare functions are concerned), the
 * old element is replaced by this new element.
 */
void hashset_enter(hashset *h, const void *elem_addr);

/*
 * Examine the specified hashset to see if anything matches
 * the item residing at the specified elem_addr (in terms of 
 * the hash and compare functions). 
 * If a match is found, return the address of the stored item.
 * If no match is found, return NULL.
 */
void *hashset_lookup(const hashset *h, const void *elem_addr);

/*
 * Apply the specified map_fun to the addresses of each element residing 
 * in the hashset. 
 * aux_data can be used to propagate additional data to 
 * each of the map_fun calls.
 * If no additiona data is needed, aux_data is NULL.  
 */
void hashset_map(hashset *h, hashset_map_fun map_fun, void *aux_data);
     
#endif