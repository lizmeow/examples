/*
 * CMap API.
 *
 * Motivation:
 * CMap manages a collection of key-value pairs or "entries". The keys
 * are always of type char *, but the values can be of any desired type.
 * CMap is efficient for associating a value with a key and to retrieve
 * the value associated with a key.
 *
 * CMap avoids the "code bloat" generated by template classes in C++.
 *
 * Reference:
 * Stanford CS107
 *
 * Authors:
 * Jerry Cain, revised by Elizabeth Howe
 */

#ifndef _cmap_h
#define _cmap_h

#include <stddef.h>

 /*
  * A client-supplied cleanup function that will be applied to a value
  * that is being removed/replaced/disposed.
  * addr points to the value to be cleaned up.
  */
typedef void (*free_fun)(void *addr);

/* Define the CMap type */
typedef struct CMap_internals CMap;

/*
 * Return a pointer to a new dynamically-allocated empty CMap.
 * When done with the CMap, client must call cmap_dispose to deallocate
 * memory.
 *
 * value_size specifies the size, in bytes, of each value that will
 * be stored in the CMap. All values stored in a given CMap must be of
 * the same type.
 *
 * capacity_hint is an estimate of the number of entries that will be stored
 * in this CMap. The internal storage will be optimized for this size.
 * If the number of entries exceeds original hint, the map accepts additional
 * entries but performance may suffer. If capacity_hint is 0, an internal
 * default value is used.
 *
 * fn is a client callback called on a value being removed/replaced
 * (via cmap_remove/cmap_put, respectively), and on every value when
 * the CMap is destroyed (via cmap_dispose).
 * When set to NULL, no special cleanup is required.
 * O(1) time.
 */
CMap *cmap_create(size_t value_size, size_t capacity_hint, free_fun fn);

/*
 * Dispose of the CMap and deallocate memory.
 * O(N) time.
 */
void cmap_dispose(CMap *cm);

/*
 * Return the number of entries currently stored in the CMap.
 * O(1) time.
 */
int cmap_count(const CMap *cm);

/*
 * Associate the given key with a new value in the CMap.
 * If there is an existing value for the key, replace it with the new value.
 * Copy the key string and copy the value at addr to store in the CMap.
 * O(1) time (amortized).
 */
void cmap_put(CMap *cm, const char *key, const void *addr);

/*
 * Search the CMap for an entry with the given key.
 * If found, return a pointer to the memory location where its associated value
 * is stored.
 * If not found, return NULL.
 * O(1) time.
 */
void *cmap_get(const CMap *cm, const char *key);

/*
 * Allow for iteration over the CMap keys.
 * Keys are iterated in arbitrary order.
 * Return the address of one key, or NULL if the CMap is empty.
 * O(1) time (amortized).
 */
const char *cmap_first(const CMap *cm);

/*
 * Return the address of one key, or NULL if there is no next key.
 * O(1) time (amortized).
 */
const char *cmap_next(const CMap *cm, const char *prev_key);

#endif
