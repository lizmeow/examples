/*
 * CMap interface.
 *
 * Motivation:
 * The CMap manages a collection of key-value pairs or "entries". The keys
 * are always of type char *, but the values can be of any desired type.
 * The CMap is efficient for associating a value with a key and to retrieve
 * the value associated with a key.
 * The CMap avoids the "code bloat" generated by template classes in C++.
 *
 * Reference:
 * Stanford CS107
 *
 * Authors:
 * Jerry Cain, revised by Elizabeth Howe
 */

#ifndef _cmap_h
#define _cmap_h

#include <stddef.h>

 /*
  * A client-supplied cleanup function that will be applied to a value
  * that is being removed/replaced/disposed.
  * addr points to the value to be cleaned up.
  */
typedef void (*free_fun)(void *addr);

/*
 * Defines the CMap type */
typedef struct CMap_internals CMap;

/*
 * Return a pointer to a new dynamically-allocated empty CMap.
 * When done with the CMap, the client must call cmap_dispose to deallocate
 * memory.
 *
 * value_size specifies the size, in bytes, of the type of values that will
 * be stored in the CMap.
 * All values stored in a given CMap must be of the same type.
 *
 * capacity_hint is an estimate of the number of entries that will be stored
 * in this CMap. The internal storage will be optimized for this size.
 * If the number of entries exceeds original hint, the map accepts
 * additional entries but performance may suffer.
 * If capacity_hint is 0, an internal default value is used.
 * The CMap has its best performance when the given capacity_hint is close
 * to the number of entries added.
 *
 * fn is a client callback that will be called on a value being
 * removed/replaced (via cmap_remove/cmap_put, respectively) and on every value
 * in the CMap when it is destroyed (via cmap_dispose).
 * The client can pass NULL for fn if values don't require any
 * cleanup.
 * O(1) time.
 */
CMap *cmap_create(size_t value_size, size_t capacity_hint, free_fun fn);

/*
 * Dispose of the CMap and deallocate memory.
 * O(N) time.
 */
void cmap_dispose(CMap *cm);

/*
 * Return the number of entries currently stored in the CMap.
 * O(1) time.
 */
int cmap_count(const CMap *cm);

/*
 * Associate the given key with a new value in the CMap.
 * If there is an existing value for the key, replace it with the new value.
 * Copy the key string and copy the value at addr to store in the CMap.
 * O(1) time (amortized).
 */
void cmap_put(CMap *cm, const char *key, const void *addr);

/*
 * Search the CMap for an entry with the given key.
 * If found, return a pointer to the memory location where its associated value
 * is stored.
 * If key is not found, return NULL.
 * O(1) time.
 */
void *cmap_get(const CMap *cm, const char *key);

/*
 * Allow for iteration over the CMap keys.
 * Keys are iterated in arbitrary order.
 * Return one of keys, or NULL if the CMap is empty.
 * O(1) time (amortized).
 */
const char *cmap_first(const CMap *cm);
const char *cmap_next(const CMap *cm, const char *prev_key);

#endif
